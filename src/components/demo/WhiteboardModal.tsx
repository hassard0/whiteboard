import { useEffect, useRef, useState, useCallback } from "react";
import { renderedSvgCache } from "@/pages/Concepts";
import { motion, AnimatePresence } from "framer-motion";
import { X, Pencil, Highlighter, Trash2, Palette, ChevronDown, Minus, Plus, Wand2, Download, Loader2, Sparkles } from "lucide-react";
import { cn } from "@/lib/utils";
import { renderMermaid } from "@/lib/mermaid-queue";
import { supabase } from "@/integrations/supabase/client";

// ─── Types ───────────────────────────────────────────────────────────────────

interface DiagramOption {
  id: string;
  name: string;
  svg: string;
  diagram?: string;
}

interface WhiteboardModalProps {
  diagrams: DiagramOption[];
  onClose: () => void;
}

type Tool = "draw" | "highlight" | "erase";

// ─── Palette colours ─────────────────────────────────────────────────────────

const PALETTE = [
  { label: "Red",     value: "hsl(0 85% 60%)"   },
  { label: "Purple",  value: "hsl(262 83% 68%)" },
  { label: "Teal",    value: "hsl(174 62% 57%)" },
  { label: "Gold",    value: "hsl(45 90% 60%)"  },
  { label: "Coral",   value: "hsl(0 72% 65%)"   },
  { label: "Sky",     value: "hsl(200 70% 60%)"  },
  { label: "Green",   value: "hsl(142 60% 55%)"  },
  { label: "White",   value: "hsl(0 0% 95%)"     },
  { label: "Orange",  value: "hsl(25 90% 58%)"   },
];

const BG_OPTIONS = [
  { label: "Dark",     value: "hsl(240 10% 4%)"  },
  { label: "Navy",     value: "hsl(222 47% 8%)"  },
  { label: "Charcoal", value: "hsl(220 13% 12%)" },
  { label: "Slate",    value: "hsl(215 28% 17%)" },
  { label: "White",    value: "hsl(0 0% 97%)"    },
];

const MIN_ZOOM = 0.5;
const MAX_ZOOM = 4;

// ─── Component ───────────────────────────────────────────────────────────────

export function WhiteboardModal({ diagrams, onClose }: WhiteboardModalProps) {
  // Two-canvas approach: bottom = diagram (redrawn on zoom/bg changes), top = annotations (user strokes)
  const diagramCanvasRef = useRef<HTMLCanvasElement>(null);
  const annotationCanvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  const [selectedDiagramIdx, setSelectedDiagramIdx] = useState(0);
  const [tool, setTool] = useState<Tool>("draw");
  const [color, setColor] = useState(PALETTE[0].value);
  const [bg, setBg] = useState(BG_OPTIONS[0].value);
  const [strokeWidth, setStrokeWidth] = useState(3);
  const [isDrawing, setIsDrawing] = useState(false);
  const [showBgPicker, setShowBgPicker] = useState(false);
  const [showColorPicker, setShowColorPicker] = useState(false);
  const [showDiagramPicker, setShowDiagramPicker] = useState(false);
  const [zoom, setZoom] = useState(1);
  const [pan, setPan] = useState({ x: 0, y: 0 });

  // ─── Magic modal state ────────────────────────────────────────────────────
  const [showMagicModal, setShowMagicModal] = useState(false);
  const [magicPrompt, setMagicPrompt] = useState("");
  const [magicLoading, setMagicLoading] = useState(false);
  const [magicError, setMagicError] = useState("");

  // ─── Custom diagrams generated by magic ──────────────────────────────────
  const [customDiagrams, setCustomDiagrams] = useState<DiagramOption[]>([]);

  // All diagrams = prop diagrams + custom ones
  const allDiagrams = [...diagrams, ...customDiagrams];

  // Local SVG store — seed from pre-rendered cache passed in props, plus the global renderedSvgCache
  const [svgStore, setSvgStore] = useState<Record<string, string>>(() => {
    const store: Record<string, string> = {};
    for (const d of diagrams) {
      const cached = d.svg || renderedSvgCache[d.id] || "";
      if (cached) store[d.id] = cached;
    }
    return store;
  });

  const lastPos = useRef<{ x: number; y: number } | null>(null);
  const isPanning = useRef(false);
  const panStart = useRef<{ x: number; y: number } | null>(null);
  const canvasSize = useRef({ w: 0, h: 0 });
  const highlightSnapshot = useRef<ImageData | null>(null);
  const highlightPoints = useRef<{ x: number; y: number }[]>([]);
  const renderingRef = useRef<Set<string>>(new Set());
  // Track drawing state in a ref to avoid stale closures in effects
  const isDrawingRef = useRef(false);

  // ─── Escape key ─────────────────────────────────────────────────────────────
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        if (showMagicModal) { setShowMagicModal(false); return; }
        onClose();
      }
    };
    document.addEventListener("keydown", handler);
    return () => document.removeEventListener("keydown", handler);
  }, [onClose, showMagicModal]);

  // ─── Pre-render ALL uncached diagrams on mount ───────────────────────────
  useEffect(() => {
    function tryRender(d: DiagramOption) {
      if (!d.diagram) return;
      if (renderingRef.current.has(d.id)) return;
      renderingRef.current.add(d.id);
      renderMermaid(d.diagram)
        .then((svg) => {
          setSvgStore((prev) => ({ ...prev, [d.id]: svg }));
          renderingRef.current.delete(d.id);
        })
        .catch((err) => {
          console.error(`[Whiteboard] render failed for "${d.name}":`, err);
          renderingRef.current.delete(d.id);
          // Retry once after a short delay
          setTimeout(() => {
            if (!svgStore[d.id]) {
              renderingRef.current.add(d.id);
              renderMermaid(d.diagram!)
                .then((svg) => setSvgStore((prev) => ({ ...prev, [d.id]: svg })))
                .catch((e) => console.error(`[Whiteboard] retry failed for "${d.name}":`, e))
                .finally(() => renderingRef.current.delete(d.id));
            }
          }, 2500);
        });
    }
    // Stagger slightly so we don't hammer the queue with all diagrams at once.
    // Skip any diagram already seeded into svgStore (from cache or props).
    let delay = 0;
    diagrams.forEach((d) => {
      const alreadyCached = !!(d.svg || renderedSvgCache[d.id]);
      if (!alreadyCached) {
        setTimeout(() => tryRender(d), delay);
        delay += 100;
      }
    });
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // ─── Refs that allow drawDiagram to be stable (no deps) ──────────────────
  // drawDiagram reads everything from refs so it never needs to be recreated,
  // which prevents it from being called by useEffect on every render/draw stroke.
  const svgStoreRef = useRef(svgStore);
  const allDiagramsRef = useRef(allDiagrams);
  const selectedDiagramIdxRef = useRef(selectedDiagramIdx);
  const bgRef = useRef(bg);

  useEffect(() => { svgStoreRef.current = svgStore; }, [svgStore]);
  useEffect(() => { allDiagramsRef.current = allDiagrams; }, [allDiagrams]);
  useEffect(() => { selectedDiagramIdxRef.current = selectedDiagramIdx; }, [selectedDiagramIdx]);
  useEffect(() => { bgRef.current = bg; }, [bg]);

  // ─── Draw diagram onto the bottom (diagram) canvas ───────────────────────
  const drawGenRef = useRef(0);

  // Stable callback — no deps, always reads latest values from refs.
  const drawDiagram = useCallback(() => {
    const canvas = diagramCanvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const { w, h } = canvasSize.current;
    const currentBg = bgRef.current;
    const svgStr = svgStoreRef.current[allDiagramsRef.current[selectedDiagramIdxRef.current]?.id ?? ""];

    // Bump generation counter — stale async renders will be discarded
    const gen = ++drawGenRef.current;

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = currentBg;
    ctx.fillRect(0, 0, w, h);

    if (!svgStr) return;

    const blob = new Blob([svgStr], { type: "image/svg+xml" });
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => {
      if (gen !== drawGenRef.current) { URL.revokeObjectURL(url); return; }
      const padding = Math.min(w, h) * 0.05;
      const maxW = w - padding * 2;
      const maxH = h - padding * 2;
      const scale = Math.min(maxW / img.width, maxH / img.height);
      const drawW = img.width * scale;
      const drawH = img.height * scale;
      const x = (w - drawW) / 2;
      const y = (h - drawH) / 2;
      // Final clear+fill+draw so we don't get half-painted frames
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = currentBg;
      ctx.fillRect(0, 0, w, h);
      ctx.drawImage(img, x, y, drawW, drawH);
      URL.revokeObjectURL(url);
    };
    img.onerror = () => URL.revokeObjectURL(url);
    img.src = url;
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // intentionally empty — all state read through refs

  // ─── Initialise canvases once on mount ────────────────────────────────────
  useEffect(() => {
    const container = containerRef.current;
    const dCanvas = diagramCanvasRef.current;
    const aCanvas = annotationCanvasRef.current;
    if (!container || !dCanvas || !aCanvas) return;

    const rect = container.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    canvasSize.current = { w, h };

    dCanvas.width = w;
    dCanvas.height = h;
    aCanvas.width = w;
    aCanvas.height = h;

    drawDiagram();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // run once

  // ─── Redraw when diagram selection, svgStore, or bg changes ──────────────
  // Guard against redrawing mid-stroke (would wipe the background visually)
  useEffect(() => {
    if (!isDrawingRef.current) {
      drawDiagram();
    }
  }, [svgStore, selectedDiagramIdx, bg, drawDiagram]);

  // ─── Scroll to zoom ───────────────────────────────────────────────────────
  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;
    const onWheel = (e: WheelEvent) => {
      e.preventDefault();
      const delta = e.deltaY < 0 ? 0.1 : -0.1;
      setZoom((z) => Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, +(z + delta).toFixed(2))));
    };
    el.addEventListener("wheel", onWheel, { passive: false });
    return () => el.removeEventListener("wheel", onWheel);
  }, []);

  // ─── Magic diagram generation ─────────────────────────────────────────────
  async function generateMagicDiagram() {
    if (!magicPrompt.trim()) return;
    setMagicLoading(true);
    setMagicError("");
    try {
      const { data, error } = await supabase.functions.invoke("generate-mermaid", {
        body: { description: magicPrompt.trim() },
      });
      if (error) throw new Error(error.message ?? "Edge function error");
      const mermaidCode: string = data?.mermaid;
      if (!mermaidCode) throw new Error("No diagram code returned from AI");

      // Attempt to render; on failure, retry once with sanitised fallback
      let svg: string;
      try {
        svg = await renderMermaid(mermaidCode);
      } catch (renderErr: any) {
        console.warn("[Magic] First render failed, retrying sanitised:", renderErr?.message);
        // Drop lines with bare colons in unquoted node labels — common LLM mistake
        const cleaned = mermaidCode.split("\n").filter((l) => {
          const t = l.trim();
          return !(t.match(/^\w+\[.*:.*\]/) && !t.includes('"'));
        }).join("\n");
        svg = await renderMermaid(cleaned);
      }

      const id = `custom-${Date.now()}`;
      const name = magicPrompt.trim().slice(0, 40) + (magicPrompt.length > 40 ? "…" : "");
      const newDiagram: DiagramOption = { id, name, svg, diagram: mermaidCode };

      setCustomDiagrams((prev) => [...prev, newDiagram]);
      setSvgStore((prev) => ({ ...prev, [id]: svg }));

      // Switch to the new diagram
      const newIdx = allDiagrams.length;
      setSelectedDiagramIdx(newIdx);
      setPan({ x: 0, y: 0 });
      setZoom(1);

      setShowMagicModal(false);
      setMagicPrompt("");
    } catch (err: any) {
      console.error("[Magic] generation failed:", err);
      setMagicError(err?.message ?? "Generation failed — please try again");
    } finally {
      setMagicLoading(false);
    }
  }

  // ─── Save as PNG ──────────────────────────────────────────────────────────
  // We cannot use drawImage(diagramCanvas) because loading an SVG via a blob URL
  // taints that canvas, causing a SecurityError on toBlob/toDataURL.
  // Instead we re-render the SVG string directly into the export canvas ourselves.
  function saveAsPng() {
    const aCanvas = annotationCanvasRef.current;
    if (!aCanvas) return;

    const { w, h } = canvasSize.current;
    const merged = document.createElement("canvas");
    merged.width = w;
    merged.height = h;
    const ctx = merged.getContext("2d")!;

    // 1. Fill background
    ctx.fillStyle = bgRef.current;
    ctx.fillRect(0, 0, w, h);

    const svgStr = svgStoreRef.current[allDiagramsRef.current[selectedDiagramIdxRef.current]?.id ?? ""];

    function compositeAnnotationsAndDownload() {
      // 2. Draw annotation layer (user strokes) on top
      ctx.drawImage(aCanvas!, 0, 0);

      merged.toBlob((blob) => {
        if (!blob) { console.error("[saveAsPng] toBlob returned null"); return; }
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `whiteboard-${new Date().toISOString().slice(0, 10)}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      }, "image/png");
    }

    if (svgStr) {
      // Re-render SVG into a fresh Image — this is not tainted because we own the blob
      const blob = new Blob([svgStr], { type: "image/svg+xml" });
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = () => {
        const padding = Math.min(w, h) * 0.05;
        const scale = Math.min((w - padding * 2) / img.width, (h - padding * 2) / img.height);
        const drawW = img.width * scale;
        const drawH = img.height * scale;
        ctx.drawImage(img, (w - drawW) / 2, (h - drawH) / 2, drawW, drawH);
        URL.revokeObjectURL(url);
        compositeAnnotationsAndDownload();
      };
      img.onerror = () => { URL.revokeObjectURL(url); compositeAnnotationsAndDownload(); };
      img.src = url;
    } else {
      compositeAnnotationsAndDownload();
    }
  }

  // ─── Pointer helpers ──────────────────────────────────────────────────────
  function getPos(e: React.PointerEvent<HTMLCanvasElement>) {
    const canvas = annotationCanvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
  }

  function onPointerDown(e: React.PointerEvent<HTMLCanvasElement>) {
    if (e.button === 2) {
      e.preventDefault();
      isPanning.current = true;
      panStart.current = { x: e.clientX, y: e.clientY };
      annotationCanvasRef.current?.setPointerCapture(e.pointerId);
      return;
    }
    const pos = getPos(e);
    if (tool === "highlight") {
      const ctx = annotationCanvasRef.current?.getContext("2d");
      if (ctx) highlightSnapshot.current = ctx.getImageData(0, 0, canvasSize.current.w, canvasSize.current.h);
      highlightPoints.current = [pos];
    }
    isDrawingRef.current = true;
    setIsDrawing(true);
    lastPos.current = pos;
    annotationCanvasRef.current?.setPointerCapture(e.pointerId);
  }

  function onPointerMove(e: React.PointerEvent<HTMLCanvasElement>) {
    if (isPanning.current && panStart.current) {
      const dx = e.clientX - panStart.current.x;
      const dy = e.clientY - panStart.current.y;
      setPan((p) => ({ x: p.x + dx, y: p.y + dy }));
      panStart.current = { x: e.clientX, y: e.clientY };
      return;
    }
    if (!isDrawingRef.current || !lastPos.current) return;
    const canvas = annotationCanvasRef.current;
    const ctx = canvas?.getContext("2d");
    if (!ctx || !canvas) return;
    const pos = getPos(e);

    if (tool === "highlight") {
      highlightPoints.current.push(pos);
      if (highlightSnapshot.current) ctx.putImageData(highlightSnapshot.current, 0, 0);
      const pts = highlightPoints.current;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.globalAlpha = 0.35;
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = color;
      ctx.lineWidth = strokeWidth * 5;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.stroke();
      ctx.restore();
    } else {
      ctx.beginPath();
      ctx.moveTo(lastPos.current.x, lastPos.current.y);
      ctx.lineTo(pos.x, pos.y);
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      if (tool === "erase") {
        ctx.globalCompositeOperation = "destination-out";
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.lineWidth = strokeWidth * 6;
      } else {
        ctx.globalCompositeOperation = "source-over";
        ctx.strokeStyle = color;
        ctx.lineWidth = strokeWidth;
      }
      ctx.stroke();
      ctx.globalCompositeOperation = "source-over";
    }
    lastPos.current = pos;
  }

  function onPointerUp() {
    if (isPanning.current) { isPanning.current = false; panStart.current = null; return; }
    highlightSnapshot.current = null;
    highlightPoints.current = [];
    isDrawingRef.current = false;
    setIsDrawing(false);
    lastPos.current = null;
    const ctx = annotationCanvasRef.current?.getContext("2d");
    if (ctx) { ctx.globalCompositeOperation = "source-over"; ctx.globalAlpha = 1; }
  }

  function clearCanvas() {
    const ctx = annotationCanvasRef.current?.getContext("2d");
    if (ctx) ctx.clearRect(0, 0, canvasSize.current.w, canvasSize.current.h);
  }

  const toolButtons: { id: Tool; icon: React.ReactNode; label: string }[] = [
    { id: "draw",      icon: <Pencil className="h-4 w-4" />,      label: "Draw"      },
    { id: "highlight", icon: <Highlighter className="h-4 w-4" />, label: "Highlight" },
    { id: "erase",     icon: <Trash2 className="h-4 w-4" />,      label: "Erase"     },
  ];

  const selectedDiagram = allDiagrams[selectedDiagramIdx];
  const currentSvgReady = !!(svgStore[selectedDiagram?.id ?? ""]);

  return (
    <AnimatePresence>
      <motion.div
        className="fixed inset-0 z-50 flex flex-col"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
      >
        {/* Overlay */}
        <div className="absolute inset-0 bg-background/95 backdrop-blur-md" onClick={onClose} />

        {/* Modal */}
        <motion.div
          className="relative z-10 flex flex-col w-full h-full max-w-[1400px] max-h-[95vh] m-auto rounded-2xl border border-border/60 bg-card shadow-2xl overflow-hidden"
          initial={{ scale: 0.94, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.94, opacity: 0 }}
          transition={{ type: "spring", stiffness: 320, damping: 30 }}
          onClick={(e) => e.stopPropagation()}
        >
          {/* ── Toolbar ── */}
          <div className="flex items-center gap-3 px-4 py-3 border-b border-border/40 bg-card/80 flex-wrap">

            {/* Diagram picker */}
            <div className="relative">
              <button
                onClick={() => { setShowDiagramPicker(!showDiagramPicker); setShowBgPicker(false); setShowColorPicker(false); }}
                className="flex items-center gap-2 rounded-lg border border-border/60 bg-background px-3 py-1.5 text-xs font-medium text-foreground hover:bg-accent transition-colors"
              >
                <span className="max-w-[140px] truncate">{selectedDiagram?.name ?? "Select diagram"}</span>
                <ChevronDown className="h-3 w-3 text-muted-foreground" />
              </button>
              {showDiagramPicker && (
                <div className="absolute top-full left-0 mt-1 z-20 min-w-[220px] rounded-xl border border-border bg-card shadow-xl py-1 max-h-80 overflow-y-auto">
                  <button
                    onClick={() => { setSelectedDiagramIdx(-1); setShowDiagramPicker(false); setPan({ x: 0, y: 0 }); setZoom(1); }}
                    className={cn(
                      "w-full text-left px-3 py-2 text-xs transition-colors hover:bg-accent",
                      selectedDiagramIdx === -1 ? "text-primary font-medium" : "text-foreground"
                    )}
                  >
                    — No diagram (blank canvas)
                  </button>
                  {diagrams.length > 0 && (
                    <div className="px-3 py-1 text-[10px] text-muted-foreground font-medium uppercase tracking-wide border-t border-border/40 mt-1 pt-2">
                      Demo Flows
                    </div>
                  )}
                  {diagrams.map((d, i) => (
                    <button
                      key={d.id}
                      onClick={() => { setSelectedDiagramIdx(i); setShowDiagramPicker(false); setPan({ x: 0, y: 0 }); setZoom(1); clearCanvas(); }}
                      className={cn(
                        "w-full text-left px-3 py-2 text-xs transition-colors hover:bg-accent flex items-center gap-2",
                        selectedDiagramIdx === i ? "text-primary font-medium" : "text-foreground"
                      )}
                    >
                      <span className="flex-1 truncate">{d.name}</span>
                      {!svgStore[d.id] && <span className="text-[9px] text-muted-foreground shrink-0">rendering…</span>}
                    </button>
                  ))}
                  {customDiagrams.length > 0 && (
                    <>
                      <div className="px-3 py-1 text-[10px] text-muted-foreground font-medium uppercase tracking-wide border-t border-border/40 mt-1 pt-2">
                        Generated
                      </div>
                      {customDiagrams.map((d, i) => (
                        <button
                          key={d.id}
                          onClick={() => { setSelectedDiagramIdx(diagrams.length + i); setShowDiagramPicker(false); setPan({ x: 0, y: 0 }); setZoom(1); clearCanvas(); }}
                          className={cn(
                            "w-full text-left px-3 py-2 text-xs transition-colors hover:bg-accent flex items-center gap-2",
                            selectedDiagramIdx === diagrams.length + i ? "text-primary font-medium" : "text-foreground"
                          )}
                        >
                          <Sparkles className="h-3 w-3 text-primary shrink-0" />
                          <span className="flex-1 truncate">{d.name}</span>
                        </button>
                      ))}
                    </>
                  )}
                </div>
              )}
            </div>

            {/* Tool selector */}
            <div className="flex items-center gap-1 rounded-lg border border-border/60 bg-background p-0.5">
              {toolButtons.map((btn) => (
                <button
                  key={btn.id}
                  title={btn.label}
                  onClick={() => setTool(btn.id)}
                  className={cn(
                    "flex items-center gap-1.5 rounded-md px-2.5 py-1 text-xs transition-colors",
                    tool === btn.id
                      ? "bg-primary text-primary-foreground"
                      : "text-muted-foreground hover:text-foreground hover:bg-accent"
                  )}
                >
                  {btn.icon}
                  <span className="hidden sm:inline">{btn.label}</span>
                </button>
              ))}
            </div>

            {/* Stroke width */}
            <div className="flex items-center gap-1">
              {[2, 4, 7].map((w) => (
                <button
                  key={w}
                  onClick={() => setStrokeWidth(w)}
                  className={cn(
                    "flex items-center justify-center rounded-full border transition-colors",
                    strokeWidth === w ? "border-primary" : "border-border/60 hover:border-border"
                  )}
                  style={{ width: w + 10, height: w + 10 }}
                >
                  <div
                    className="rounded-full"
                    style={{
                      width: w,
                      height: w,
                      backgroundColor: strokeWidth === w ? color : "hsl(var(--muted-foreground))",
                    }}
                  />
                </button>
              ))}
            </div>

            {/* Colour picker */}
            <div className="relative">
              <button
                title="Pen colour"
                onClick={() => { setShowColorPicker(!showColorPicker); setShowBgPicker(false); setShowDiagramPicker(false); }}
                className="flex items-center gap-1.5 rounded-lg border border-border/60 bg-background px-2.5 py-1.5 text-xs text-muted-foreground hover:text-foreground hover:bg-accent transition-colors"
              >
                <div className="h-3.5 w-3.5 rounded-full border border-border/60" style={{ backgroundColor: color }} />
                <span className="hidden sm:inline">Colour</span>
              </button>
              {showColorPicker && (
                <div className="absolute top-full left-0 mt-1 z-20 rounded-xl border border-border bg-card shadow-xl p-3">
                  <p className="text-[10px] text-muted-foreground mb-2 font-medium">Pen</p>
                  <div className="flex flex-wrap gap-1.5 max-w-[160px]">
                    {PALETTE.map((c) => (
                      <button
                        key={c.value}
                        title={c.label}
                        onClick={() => { setColor(c.value); setShowColorPicker(false); }}
                        className={cn(
                          "h-7 w-7 rounded-full border-2 transition-all hover:scale-110",
                          color === c.value ? "border-primary ring-2 ring-primary/40" : "border-transparent"
                        )}
                        style={{ backgroundColor: c.value }}
                      />
                    ))}
                  </div>
                </div>
              )}
            </div>

            {/* Background picker */}
            <div className="relative">
              <button
                title="Canvas background"
                onClick={() => { setShowBgPicker(!showBgPicker); setShowColorPicker(false); setShowDiagramPicker(false); }}
                className="flex items-center gap-1.5 rounded-lg border border-border/60 bg-background px-2.5 py-1.5 text-xs text-muted-foreground hover:text-foreground hover:bg-accent transition-colors"
              >
                <Palette className="h-3.5 w-3.5" />
                <span className="hidden sm:inline">Canvas</span>
              </button>
              {showBgPicker && (
                <div className="absolute top-full left-0 mt-1 z-20 rounded-xl border border-border bg-card shadow-xl p-3">
                  <p className="text-[10px] text-muted-foreground mb-2 font-medium">Background</p>
                  <div className="flex flex-wrap gap-1.5 max-w-[160px]">
                    {BG_OPTIONS.map((b) => (
                      <button
                        key={b.value}
                        title={b.label}
                        onClick={() => { setBg(b.value); setShowBgPicker(false); }}
                        className={cn(
                          "h-7 w-7 rounded-full border-2 transition-all hover:scale-110",
                          bg === b.value ? "border-primary ring-2 ring-primary/40" : "border-border/60"
                        )}
                        style={{ backgroundColor: b.value }}
                      />
                    ))}
                  </div>
                </div>
              )}
            </div>

            <div className="h-5 w-px bg-border/60" />

            {/* Zoom controls */}
            <div className="flex items-center gap-1">
              <button
                onClick={() => setZoom((z) => Math.max(MIN_ZOOM, +(z - 0.25).toFixed(2)))}
                className="rounded-md p-1.5 text-muted-foreground hover:text-foreground hover:bg-accent transition-colors"
                title="Zoom out"
              >
                <Minus className="h-3.5 w-3.5" />
              </button>
              <button
                onClick={() => setZoom(1)}
                className="min-w-[40px] rounded-md px-1.5 py-1 text-[10px] font-mono text-muted-foreground hover:text-foreground hover:bg-accent transition-colors text-center"
                title="Reset zoom"
              >
                {Math.round(zoom * 100)}%
              </button>
              <button
                onClick={() => setZoom((z) => Math.min(MAX_ZOOM, +(z + 0.25).toFixed(2)))}
                className="rounded-md p-1.5 text-muted-foreground hover:text-foreground hover:bg-accent transition-colors"
                title="Zoom in"
              >
                <Plus className="h-3.5 w-3.5" />
              </button>
            </div>

            <div className="h-5 w-px bg-border/60" />

            {/* Clear annotations */}
            <button
              onClick={clearCanvas}
              className="flex items-center gap-1.5 rounded-lg border border-border/60 bg-background px-2.5 py-1.5 text-xs text-muted-foreground hover:text-destructive hover:bg-destructive/10 hover:border-destructive/40 transition-colors"
            >
              <Trash2 className="h-3.5 w-3.5" />
              <span className="hidden sm:inline">Clear</span>
            </button>

            {/* Magic diagram generator */}
            <button
              onClick={() => { setShowMagicModal(true); setMagicError(""); }}
              className="flex items-center gap-1.5 rounded-lg border border-primary/40 bg-primary/10 px-2.5 py-1.5 text-xs text-primary hover:bg-primary/20 hover:border-primary/60 transition-colors"
              title="Generate a diagram with AI"
            >
              <Wand2 className="h-3.5 w-3.5" />
              <span className="hidden sm:inline">Magic</span>
            </button>

            {/* Save as PNG */}
            <button
              onClick={saveAsPng}
              className="flex items-center gap-1.5 rounded-lg border border-border/60 bg-background px-2.5 py-1.5 text-xs text-muted-foreground hover:text-foreground hover:bg-accent transition-colors"
              title="Save whiteboard as PNG"
            >
              <Download className="h-3.5 w-3.5" />
              <span className="hidden sm:inline">Save PNG</span>
            </button>

            {/* Spacer + hint + Close */}
            <div className="ml-auto flex items-center gap-2">
              <span className="text-[10px] text-muted-foreground hidden md:block">
                Scroll to zoom · right-drag to pan
              </span>
              <button
                onClick={onClose}
                className="rounded-lg p-1.5 text-muted-foreground hover:text-foreground hover:bg-accent transition-colors"
              >
                <X className="h-4 w-4" />
              </button>
            </div>
          </div>

          {/* ── Canvas area ── */}
          <div ref={containerRef} className="flex-1 overflow-hidden relative select-none">
            {!currentSvgReady && selectedDiagramIdx >= 0 && (
              <div className="absolute inset-0 flex items-center justify-center z-10 pointer-events-none">
                <span className="text-xs text-muted-foreground animate-pulse">Rendering diagram…</span>
              </div>
            )}

            {/* Zoom/pan wrapper — CSS transform only, never causes canvas redraw */}
            <div
              className="absolute inset-0"
              style={{
                transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
                transformOrigin: "center center",
              }}
            >
              {/* Bottom canvas: diagram + background — pointer-events none so drawing goes to annotation layer */}
              <canvas
                ref={diagramCanvasRef}
                className="absolute inset-0 w-full h-full"
                style={{ zIndex: 1, pointerEvents: "none" }}
              />
              {/* Top canvas: annotation layer — receives all pointer events */}
              <canvas
                ref={annotationCanvasRef}
                className={cn(
                  "absolute inset-0 w-full h-full",
                  tool === "draw" && "cursor-crosshair",
                  tool === "highlight" && "cursor-cell",
                  tool === "erase" && "cursor-cell",
                )}
                onContextMenu={(e) => e.preventDefault()}
                onPointerDown={onPointerDown}
                onPointerMove={onPointerMove}
                onPointerUp={onPointerUp}
                onPointerLeave={onPointerUp}
                style={{ zIndex: 2, cursor: isPanning.current ? "grabbing" : undefined }}
              />
            </div>
          </div>
        </motion.div>

        {/* ── Magic Modal ── */}
        <AnimatePresence>
          {showMagicModal && (
            <motion.div
              className="absolute inset-0 flex items-center justify-center p-6"
              style={{ zIndex: 60 }}
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              onClick={() => !magicLoading && setShowMagicModal(false)}
            >
              <div className="absolute inset-0 bg-background/60 backdrop-blur-sm" />
              <motion.div
                className="relative z-10 w-full max-w-lg rounded-2xl border border-border/60 bg-card shadow-2xl p-6"
                initial={{ scale: 0.92, opacity: 0, y: 16 }}
                animate={{ scale: 1, opacity: 1, y: 0 }}
                exit={{ scale: 0.92, opacity: 0, y: 16 }}
                transition={{ type: "spring", stiffness: 340, damping: 28 }}
                onClick={(e) => e.stopPropagation()}
              >
                {/* Header */}
                <div className="flex items-center gap-3 mb-4">
                  <div className="flex h-9 w-9 items-center justify-center rounded-xl bg-primary/15 border border-primary/20">
                    <Wand2 className="h-4 w-4 text-primary" />
                  </div>
                  <div>
                    <h3 className="text-sm font-semibold text-foreground">Generate Diagram</h3>
                    <p className="text-xs text-muted-foreground">Describe any flow, sequence, or architecture</p>
                  </div>
                  <button
                    onClick={() => !magicLoading && setShowMagicModal(false)}
                    className="ml-auto rounded-lg p-1.5 text-muted-foreground hover:text-foreground hover:bg-accent transition-colors"
                  >
                    <X className="h-4 w-4" />
                  </button>
                </div>

                {/* Prompt examples */}
                <div className="flex flex-wrap gap-1.5 mb-3">
                  {[
                    "OAuth login flow",
                    "Microservices architecture",
                    "CI/CD pipeline",
                    "User signup sequence",
                  ].map((example) => (
                    <button
                      key={example}
                      onClick={() => setMagicPrompt(example)}
                      className="rounded-full border border-border/60 bg-background px-2.5 py-1 text-[10px] text-muted-foreground hover:text-foreground hover:border-border transition-colors"
                    >
                      {example}
                    </button>
                  ))}
                </div>

                {/* Textarea */}
                <textarea
                  value={magicPrompt}
                  onChange={(e) => setMagicPrompt(e.target.value)}
                  placeholder="e.g. Show how a user authenticates with Auth0, gets a JWT, and calls a protected API..."
                  rows={4}
                  disabled={magicLoading}
                  className="w-full rounded-xl border border-border/60 bg-background px-3 py-2.5 text-sm text-foreground placeholder:text-muted-foreground/60 resize-none focus:outline-none focus:ring-2 focus:ring-primary/40 focus:border-primary/40 disabled:opacity-50 transition-colors"
                  onKeyDown={(e) => {
                    if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) generateMagicDiagram();
                  }}
                />

                {magicError && (
                  <p className="mt-2 text-xs text-destructive">{magicError}</p>
                )}

                {/* Actions */}
                <div className="flex items-center justify-between mt-4">
                  <span className="text-[10px] text-muted-foreground">⌘ Enter to generate</span>
                  <div className="flex gap-2">
                    <button
                      onClick={() => !magicLoading && setShowMagicModal(false)}
                      disabled={magicLoading}
                      className="rounded-lg border border-border/60 bg-background px-3 py-1.5 text-xs text-muted-foreground hover:text-foreground hover:bg-accent transition-colors disabled:opacity-40"
                    >
                      Cancel
                    </button>
                    <button
                      onClick={generateMagicDiagram}
                      disabled={magicLoading || !magicPrompt.trim()}
                      className="flex items-center gap-2 rounded-lg bg-primary px-4 py-1.5 text-xs font-medium text-primary-foreground hover:bg-primary/90 transition-colors disabled:opacity-50"
                    >
                      {magicLoading ? (
                        <><Loader2 className="h-3.5 w-3.5 animate-spin" /> Generating…</>
                      ) : (
                        <><Sparkles className="h-3.5 w-3.5" /> Generate</>
                      )}
                    </button>
                  </div>
                </div>
              </motion.div>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    </AnimatePresence>
  );
}
